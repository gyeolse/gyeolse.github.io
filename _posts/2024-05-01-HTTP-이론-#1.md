---
layout: post
date: 2024-05-01
title: "HTTP 이론 #1"
tags: [HTTP, ]
categories: [Development, ]
---


> 💡 공부한 날 : 2021-03-25 


**HTTP/1.1 : 현재 우리가 가장 많이 사용하고, 가장 중요한 버전**



#### HTTP 특징

1. **클라이언트 ↔ 서버 구조 → 양쪽이 독립적으로 발전 가능**
	- Request, Response 구조
	- 클라이언트가 메시지를 요청하고, 서버는 요청에 대한 결과를 만들어서 응답
2. **무상태 프로토콜 (Stateless)**
	- 서버가 클라이언트의 상태를 보존하지 않는다.
	- Stateful, Stateless? → 노트북 예시
		- Stateful 하다면, Context에 혼란 발생, Stateless 하다면, 중간에 점원(서버) 바뀌어도 OK
	- **결론 : 갑자기 클라이언트의 요청이 증가한다면, 그냥 서버를 대거 투입하면 된다. → 무제한 서버 증설이 가능**
	- Scale out : 수평 확장에 유리함. (같은 기능을 하는 서버를 여러 개 확장)
	- 한계 : 할 수 있는 경우도, 없는 경우도 있음
		- 무상태 : 단순한 서비스 소개 화면
		- 상태 유지 : 로그인한 사용자의 경우, 로그인 했다는 상태를 서버에 유지. 브라우저 쿠키와 서버 세션 등을 사용해서 상태를 유지함. 상태 유지는 최소한만 사용.
		- 어쩔 수 없이 한계는 존재하지만, 꼭 필요한 경우에만 어쩔 수 없이 사용해야 한다는 점
		- 데이터를 너무 많이 보냄.
3. **비연결성**
	- 서버 연결 유지 X. 최소한의 자원 사용
	- 연결을 유지하지 않는 모델 → 서버 자원을 매우 효율적으로 사용할 수 있음
	- 한계
		- TCP/IP 연결을 새로 맺어야함 - 3 way handshake 시간 추가
		- 웹 브라우저 사이트 요청 시, 수많은 자원 (HTML, JS, CSS.. ) 한꺼번에 다운로드
		- **Persistent Connections 를 통해서 문제 해결. 연결을 일정 시간 동안 유지**

			![0](/assets/img/2024-05-01-HTTP-이론-#1.md/0.png)



#### 결론 : 스테이트리스를 기억하자. 

- 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽 ( 선착순 이벤트... 치킨할인.. )


#### HTTP 메시지


![1](/assets/img/2024-05-01-HTTP-이론-#1.md/1.png)


요청 메시지와 응답 메시지의 구조가 다름 


**요청 메시지**

- request-line = method SP(공백) request-target SP HTTP-version SP
- HTTP 메서드 : GET,  POST, PUT, DELETE
	- GET : 리소스 조회
	- POST : 요청 내역 처리

**응답 메시지** 

- status-line = HTTP-version SP status-code SP reason-phrase CRLF
- HTTP 상태 코드 : 요청 성공, 실패를 나타냄
	- 200 : 성공
	- 400 : 클라이언트 요청 오류
	- 500 : 서버 내부 오류

**HTTP 헤더** 

- HTTP 전송에 필요한 모든 부가 정보
- 예) 메시지 바디의 내용, 바디의 크기, 압충, 인증, 요청 클라이언트 정보, .....
- 필요시 임의의 헤더 추가 가능

**메시지 바디** 

- 실제 전송할 데이터
- HTML 문서, 이미지, 영상, JSON.....
